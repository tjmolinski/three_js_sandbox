<!DOCTYPE html>
<html>
  <head>
    <title> Three.js app </title>
    <meta charset="utf-8">
    <meta content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" name="viewport">
    <style>canvas { width: 100%; height: 100% }</style>
  </head>
  <body>
    <script src="js/Three.js"></script>
    <script>
      //Test goes here
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth/1.1, window.innerHeight/1.1);
      //renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      var group = new THREE.Object3D();
      var cubeGroup = new THREE.Object3D();
      var sphereGeo = new THREE.SphereGeometry(10, 20, 20, 0, Math.PI*2, 0, Math.PI);
      var cubeGeo = new THREE.CubeGeometry(1,1,1);
      var xGeo = new THREE.CubeGeometry(1,0.1, 0.1);
      var yGeo = new THREE.CubeGeometry(0.1,1,0.1);
      var zGeo = new THREE.CubeGeometry(0.1,0.1,1);
      var texture = THREE.ImageUtils.loadTexture("textures/moon.jpg");
      var crate = THREE.ImageUtils.loadTexture("textures/crate.gif");
      var material = new THREE.MeshBasicMaterial({map:texture});
      var cubeMaterial = new THREE.MeshBasicMaterial({map:crate});
      var redMat = new THREE.MeshBasicMaterial({color:0xff0000});
      var blueMat = new THREE.MeshBasicMaterial({color:0x0000ff});
      var greenMat = new THREE.MeshBasicMaterial({color:0x00ff00});
      var sphere = new THREE.Mesh(sphereGeo, material);
      var cube = new THREE.Mesh(cubeGeo, cubeMaterial);
      var cube2 = new THREE.Mesh(cubeGeo, cubeMaterial);
      var xCube = new THREE.Mesh(xGeo, redMat);
      var yCube = new THREE.Mesh(yGeo, blueMat);
      var zCube = new THREE.Mesh(zGeo, greenMat);
      //group.add(sphere);
      cubeGroup.add(cube);
      cube.add(xCube);
      cube.add(yCube);
      cube.add(zCube);
      group.add(cubeGroup);
      scene.add(group);
      
      cubeGroup.position.z = 0;
      cube2.position.x = 0;
      camera.position.z = 5;
      cube.position.x += 1;
      cube.position.y -= 1;
      cube.position.z += 1;
      xCube.position.x = 1;
      yCube.position.y = 1;
      zCube.position.z = 1;
      
      document.addEventListener('keydown', onKeyDown, false);
  
      function render() {
        //test(cube);
        lookAtCube();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        camera.lookAt( group.position );
      }
      render();



      var rotWorldMatrix;
      function rotateAroundWorldAxis(object, axis, radians) {
        rotWorldMatrix = new THREE.Matrix4();
        rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
        rotWorldMatrix.multiply(object.matrix);
        object.matrix = rotWorldMatrix;
        object.rotation.setEulerFromRotationMatrix(object.matrix);
      }

      function test(cube) {
        var pos1 = new THREE.Vector3(cube.position.x, cube.position.y, cube.position.z);
        var pos2 = new THREE.Vector3(sphere.position.x, sphere.position.y, sphere.position.z);
        var vec = new THREE.Vector3();
        if(pos1.distanceTo(pos2) > 12) {
          vec = vec.subVectors(pos2, pos1);
          cube.position.x += vec.x * 0.01;
          cube.position.y += vec.y * 0.01;
          cube.position.z += vec.z * 0.01;
        }

      }

      function lookAtCube() {
        var center = new THREE.Vector3(sphere.position.x, sphere.position.y, sphere.position.z);
        var target = new THREE.Vector3(cube.position.x, cube.position.y, cube.position.z);
        var cam = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
        var vec = new THREE.Vector3();
        vec = vec.subVectors(target, center);
        vec = vec.normalize();
        var v1 = new THREE.Vector3();
        //cube.position.x += 0.1;
        v1.x = cube.matrixWorld.getPosition().x + (vec.x * 1);
        v1.y = cube.matrixWorld.getPosition().y + (vec.y * 1);
        v1.z = cube.matrixWorld.getPosition().z + (vec.z * 1);
        //camera.applyMatrix(camera.matrix.setPosition(v1));
        //camera.matrixWorld.getPosition().x = cube.matrixWorld.getPosition().x + (vec.x*10);
        //camera.matrixWorld.getPosition().y = cube.matrixWorld.getPosition().y + (vec.y*10);
        //camera.matrixWorld.getPosition().z = cube.matrixWorld.getPosition().z + (vec.z*10);
      }

      function onKeyDown(e) {
        var rotation_matrix;
        switch(e.keyCode) {
          case 32: //Space bar
            cube.translateY(0.5);
          break;
          case 38: //Up arrow
            rotation_matrix = new THREE.Matrix4().makeRotationX(-0.02);
            cube.matrix.multiply(rotation_matrix);
            cube.rotation.setEulerFromRotationMatrix(cube.matrix);
          break;
          case 40: //Down arrow
            rotation_matrix = new THREE.Matrix4().makeRotationX(0.02);
            cube.matrix.multiply(rotation_matrix);
            cube.rotation.setEulerFromRotationMatrix(cube.matrix);
          break;
          case 39: //Right arrow
            rotation_matrix = new THREE.Matrix4().makeRotationY(0.02);
            cube.matrix.multiply(rotation_matrix);
            cube.rotation.setEulerFromRotationMatrix(cube.matrix);
          break;
          case 37: //Left arrow
            rotation_matrix = new THREE.Matrix4().makeRotationY(-0.02);
            cube.matrix.multiply(rotation_matrix);
            cube.rotation.setEulerFromRotationMatrix(cube.matrix);
          break;
        };
      }
    </script>
  </body>
</html>
